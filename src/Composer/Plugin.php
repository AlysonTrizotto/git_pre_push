<?php
namespace GitPrePush\Composer;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\Installer\PackageEvents;
use Composer\Installer\PackageEvent;
use Composer\Package\PackageInterface;

class Plugin implements PluginInterface, EventSubscriberInterface
{
    private const PACKAGE_NAME = 'alysontrizotto/git-pre-push';
    private const MARKER = '# Generated by alysontrizotto/git-pre-push';

    private Composer $composer;
    private IOInterface $io;

    public function activate(Composer $composer, IOInterface $io)
    {
        $this->composer = $composer;
        $this->io = $io;
    }

    public function deactivate(Composer $composer, IOInterface $io)
    {
        // no-op
    }

    public function uninstall(Composer $composer, IOInterface $io)
    {
        // no-op
    }

    public static function getSubscribedEvents(): array
    {
        return [
            PackageEvents::POST_PACKAGE_INSTALL => 'onPostPackageInstallOrUpdate',
            PackageEvents::POST_PACKAGE_UPDATE => 'onPostPackageInstallOrUpdate',
            PackageEvents::POST_PACKAGE_UNINSTALL => 'onPostPackageUninstall',
        ];
    }

    public function onPostPackageInstallOrUpdate(PackageEvent $event): void
    {
        $op = $event->getOperation();
        $package = method_exists($op, 'getPackage') ? $op->getPackage() : (method_exists($op, 'getTargetPackage') ? $op->getTargetPackage() : null);
        if (!$package instanceof PackageInterface) {
            return;
        }
        if ($package->getName() !== self::PACKAGE_NAME) {
            return; // not our package
        }

        $this->installHookSafely();
    }

    public function onPostPackageUninstall(PackageEvent $event): void
    {
        $op = $event->getOperation();
        $package = method_exists($op, 'getPackage') ? $op->getPackage() : null;
        if (!$package instanceof PackageInterface) {
            return;
        }
        if ($package->getName() !== self::PACKAGE_NAME) {
            return; // not our package
        }

        $this->uninstallHookSafely();
    }

    private function installHookSafely(): void
    {
        $hookPath = getcwd() . DIRECTORY_SEPARATOR . '.git' . DIRECTORY_SEPARATOR . 'hooks' . DIRECTORY_SEPARATOR . 'pre-push';
        $phpPath = PHP_BINARY ?: 'php';

        $content = "#!/bin/sh\n" . self::MARKER . "\n\n" .
            "# Safeguards: if the package or PHP is missing, skip without blocking push\n" .
            "if [ ! -f \"vendor/autoload.php\" ]; then\n" .
            "  echo \"[git-pre-push] vendor/autoload.php não encontrado. Pulando hook.\"\n" .
            "  exit 0\n" .
            "fi\n\n" .
            "PHP_BIN=\"$phpPath\"\n" .
            "if ! command -v \"\\$PHP_BIN\" >/dev/null 2>&1; then\n" .
            "  echo \"[git-pre-push] PHP não encontrado no PATH. Pulando hook.\"\n" .
            "  exit 0\n" .
            "fi\n\n" .
            "\"$phpPath\" -r \"require 'vendor/autoload.php'; if (!class_exists('GitPrePush\\\\GitPrePush')) { fwrite(STDERR, '[git-pre-push] Classe GitPrePush não encontrada. Pulando hook.\\n'); exit(0);} (new GitPrePush\\\\GitPrePush())->run();\"\n";

        if (!is_dir(dirname($hookPath))) {
            // if no .git/hooks, likely not a git repo; skip silently
            return;
        }

        file_put_contents($hookPath, $content);
        @chmod($hookPath, 0755);
        $this->io->write("<info>[git-pre-push]</info> Hook pre-push instalado em $hookPath");
    }

    private function uninstallHookSafely(): void
    {
        $hookPath = getcwd() . DIRECTORY_SEPARATOR . '.git' . DIRECTORY_SEPARATOR . 'hooks' . DIRECTORY_SEPARATOR . 'pre-push';
        if (!file_exists($hookPath)) {
            $this->io->write("<comment>[git-pre-push]</comment> Nenhum hook pre-push para remover em $hookPath");
            return;
        }
        $contents = @file_get_contents($hookPath) ?: '';
        if (strpos($contents, self::MARKER) === false) {
            $this->io->write("<comment>[git-pre-push]</comment> Hook existente não foi gerado por este pacote. Não será removido: $hookPath");
            return;
        }
        if (@unlink($hookPath)) {
            $this->io->write("<info>[git-pre-push]</info> Hook pre-push removido: $hookPath");
        } else {
            $this->io->write("<error>[git-pre-push]</error> Falha ao remover o hook em $hookPath. Verifique permissões.");
        }
    }
}
